#!/usr/bin/env python3
import argparse
import subprocess
import sys
import os
import time

# QCHI CLI: The Active Methodology Straitjacket
# This CLI enforces 100% compliance by orchestrating the LLM host (Gemini, Codex, etc.)
# in a multi-agent loop, using local linting tools to block hallucinations.

SUPPORTED_HOSTS = ["gemini", "codex", "antigravity", "opencode"]

def execute_host(host_name, prompt):
    """
    Executes the prompt using the specified local AI CLI.
    This avoids API keys by using the host's existing auth state.
    """
    if host_name == "gemini":
        cmd = ["gemini", "ask", prompt]
    elif host_name == "codex":
        cmd = ["codex", "--prompt", prompt]
    elif host_name == "antigravity":
        cmd = ["antigravity", "run", prompt]
    elif host_name == "opencode":
        cmd = ["opencode", "-c", prompt]
    else:
        raise ValueError(f"Unknown host: {host_name}")

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except FileNotFoundError:
        print(f"\n[FATAL ERROR] The host CLI '{host_name}' is not installed or not in PATH.")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"\n[FATAL ERROR] The host '{host_name}' returned an error:\n{e.stderr}")
        sys.exit(1)

def run_agent_role(host, role_name, instructions, task_context):
    """Wraps the task in QCHI's strict sub-agent persona."""
    print(f"[*] Spawning [{role_name.upper()}] Agent via {host}...")
    
    strict_prompt = f"""
    You are the {role_name.upper()} agent within the strict QCHI Research Operating Layer.
    
    CRITICAL MANDATE:
    {instructions}
    
    TASK CONTEXT:
    {task_context}
    
    Do not provide conversational filler. Output only the requested artifact.
    """
    
    return execute_host(host, strict_prompt)

def run_qchi_lint(content):
    """
    The Enforcer: Runs the Rust qchi-lint tool. 
    If this fails, the CLI will reject the LLM's output.
    """
    print("[-] Running QCHI Rigor Engine (qchi-lint)...")
    
    # In a full implementation, this writes content to a temp file and runs the Rust binary.
    # For scaffolding, we check for mandatory sections.
    if "REPRODUCED_FROM_SOURCE" not in content and "NEW_EXTENSION" not in content:
        return False, "Missing mandatory Claim Provenance Tags (e.g., NEW_EXTENSION)."
    return True, "Pass"

def orchestrate(args):
    print("=========================================")
    print("    QCHI: Research Operating Layer       ")
    print("=========================================")
    print(f"Host: {args.host} | Mode: {args.mode}")
    print(f"Task: {args.task}\n")

    # --- STAGE 1: PLANNER ---
    planner_instructions = "Decompose the given physics task into a verifiable step-by-step derivation plan. Identify all necessary limits and assumptions."
    plan = run_agent_role(args.host, "Planner", planner_instructions, args.task)
    print("\n[PLANNER OUTPUT]\n" + plan + "\n" + "-"*40)

    # --- STAGE 2: DERIVATION (With Feedback Loop) ---
    deriver_instructions = "Execute the provided plan. You MUST use analytical-first reasoning and write raw LyX code blocks for math. Include provenance tags like NEW_EXTENSION."
    
    max_retries = 3
    derivation = ""
    
    for attempt in range(1, max_retries + 1):
        derivation = run_agent_role(args.host, f"Derivation (Attempt {attempt})", deriver_instructions, f"Plan:\n{plan}")
        
        # --- STAGE 3: THE GATE (Automated Check) ---
        passed, error_msg = run_qchi_lint(derivation)
        
        if passed:
            print("\n[+] Quality Gate Passed. Derivation accepted.")
            break
        else:
            print(f"\n[!] Quality Gate Failed: {error_msg}")
            if attempt < max_retries:
                print(f"[*] Forcing AI to retry and fix errors...")
                deriver_instructions += f"\n\nYOUR LAST ATTEMPT FAILED THE QUALITY GATE: {error_msg}\nFix this immediately."
                time.sleep(2) # Prevent rate-limiting
            else:
                print("\n[FATAL ERROR] Agent failed to produce compliant output after maximum retries. Aborting.")
                sys.exit(1)

    print("\n[FINAL DERIVATION OUTPUT]\n" + derivation)
    print("=========================================")
    print("[*] QCHI Orchestration Complete.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="QCHI CLI Orchestrator")
    parser.add_argument("--host", choices=SUPPORTED_HOSTS, required=True, help="Underlying AI CLI to drive (e.g., gemini)")
    parser.add_argument("--mode", required=True, help="QCHI Execution Mode")
    parser.add_argument("--task", required=True, help="The physics task or ArXiv ID")
    
    args = parser.parse_args()
    orchestrate(args)
