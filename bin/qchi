#!/usr/bin/env python3
import argparse
import subprocess
import sys
import os
from pathlib import Path

# QCHI CLI: The Host-Native Orchestrator
# This CLI wraps around your existing installed AI CLI tools (gemini, codex, antigravity).
# It does NOT use HTTP APIs or require new API keys. It leverages your local auth.

SUPPORTED_HOSTS = ["gemini", "codex", "antigravity", "opencode"]

def setup_argparser():
    parser = argparse.ArgumentParser(description="QCHI: The Rigor-First Research Operating Layer")
    
    parser.add_argument(
        "--host", 
        choices=SUPPORTED_HOSTS,
        required=True,
        help="The local AI CLI tool to authorize and use as the engine."
    )
    
    parser.add_argument(
        "--mode", 
        choices=["physics_solve", "paper_reproduction", "parameter_space", "unfinished_project"],
        required=True,
        help="The QCHI research mode to execute."
    )
    
    parser.add_argument(
        "--task", 
        type=str,
        required=True,
        help="The specific physics task or query."
    )

    return parser

def execute_host_cli(host, prompt):
    """
    Executes the prompt using the specified local host CLI via a subprocess.
    This uses the host's native authentication and session management.
    """
    command = []
    
    # Map the host to its standard CLI execution format
    if host == "gemini":
        command = ["gemini", "ask", prompt]
    elif host == "codex":
        command = ["codex", "--prompt", prompt]
    elif host == "antigravity":
        command = ["antigravity", "run", prompt]
    elif host == "opencode":
        command = ["opencode", "-c", prompt]
        
    try:
        # Run the command and capture the output
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except FileNotFoundError:
        print(f"
[!] Error: The host CLI '{host}' is not installed or not in your system PATH.")
        print(f"    Please ensure you can run '{host}' from your terminal.")
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"
[!] Error: The host CLI '{host}' encountered an error.")
        print(f"    STDERR: {e.stderr.strip()}")
        sys.exit(1)

def run_agent(host, role, task_context):
    """Wraps the task in the strict QCHI role instructions and passes it to the host CLI."""
    print(f"[*] Authorizing {host.upper()} as [{role.upper()}] Agent...")
    
    # Construct the strict prompt based on QCHI rules
    qchi_prompt = f"""
    You are operating under the strict QCHI Research Operating Layer.
    Your Role: {role.upper()}
    
    Task: {task_context}
    
    CRITICAL RULES:
    1. You must follow the QCHI Analytical-First and Four Horsemen validation rules.
    2. Do not output conversational filler. Provide only the requested structural output.
    """
    
    output = execute_host_cli(host, qchi_prompt)
    return output

def orchestrate(args):
    print(f"=== QCHI ORCHESTRATOR STARTED ===")
    print(f"Host Engine : {args.host}")
    print(f"Mode        : {args.mode}")
    print(f"Task        : {args.task}")
    print("=================================
")

    # The QCHI Multi-Agent Workflow (simulated sequentially using the chosen host CLI)
    
    # 1. Planner Agent
    plan = run_agent(args.host, "Planner", f"Decompose this physics task into verifiable steps: {args.task}")
    print("
[PLANNER OUTPUT]")
    print(plan)
    print("-" * 40)
    
    # 2. Derivation Agent
    derivation = run_agent(args.host, "Derivation", f"Execute this plan analytically. Show all steps: {plan}")
    print("
[DERIVATION OUTPUT]")
    print(derivation)
    print("-" * 40)
    
    # 3. Verifier Agent (The Gate)
    verification = run_agent(args.host, "Verifier", f"Verify the following derivation against unit, limit, and asymptotic checks: {derivation}")
    print("
[VERIFIER OUTPUT]")
    print(verification)
    print("-" * 40)

    # Note: In a fully complete version, we would parse the Verifier output. 
    # If it says 'FAIL', we loop back to Derivation.

    print("
[*] QCHI Orchestration Cycle Complete.")

def main():
    parser = setup_argparser()
    args = parser.parse_args()
    orchestrate(args)

if __name__ == "__main__":
    main()
