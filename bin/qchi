#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
import time
import tempfile
from pathlib import Path
from textwrap import dedent

# QCHI CLI: The Active Methodology Straitjacket
# This CLI enforces 100% compliance by orchestrating the LLM host (Gemini, Codex, etc.)
# in a multi-agent loop, using local linting tools to block hallucinations.

SUPPORTED_HOSTS = ["gemini", "codex", "antigravity", "opencode"]

HOST_INSTALL_HINTS = {
    "gemini": "Install/auth Gemini CLI, then run: gemini --help",
    "codex": "Install/auth Codex CLI, then run: codex --help",
    "antigravity": "Install/auth Antigravity CLI, then run: antigravity --help",
    "opencode": "Install/auth OpenCode CLI, then run: opencode --help",
}

SCRIPT_PATH = Path(__file__).resolve()
REPO_ROOT = SCRIPT_PATH.parent.parent
DEFAULT_LINT_CANDIDATES = [
    REPO_ROOT / "tools" / "qchi-lint" / "target" / "debug" / "qchi-lint",
    REPO_ROOT / "tools" / "qchi-lint" / "target" / "release" / "qchi-lint",
]


def positive_int(value):
    try:
        parsed = int(value)
    except ValueError as exc:
        raise argparse.ArgumentTypeError(f"invalid integer value: {value}") from exc
    if parsed < 1:
        raise argparse.ArgumentTypeError("must be >= 1")
    return parsed


def resolve_lint_bin(cli_value):
    if cli_value:
        return Path(cli_value).expanduser()

    env_value = os.environ.get("QCHI_LINT_BIN")
    if env_value:
        return Path(env_value).expanduser()

    for candidate in DEFAULT_LINT_CANDIDATES:
        if candidate.exists():
            return candidate

    # Default error path if no binary exists yet.
    return DEFAULT_LINT_CANDIDATES[0]


def host_command(host_name, prompt):
    if host_name == "gemini":
        return ["gemini", "-p", prompt]
    if host_name == "codex":
        return ["codex", "--prompt", prompt]
    if host_name == "antigravity":
        return ["antigravity", "run", prompt]
    if host_name == "opencode":
        return ["opencode", "-c", prompt]
    raise ValueError(f"Unknown host: {host_name}")


def execute_host(host_name, prompt):
    """
    Executes the prompt using the specified local AI CLI.
    This avoids API keys by using the host's existing auth state.
    """
    cmd = host_command(host_name, prompt)

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except FileNotFoundError:
        hint = HOST_INSTALL_HINTS.get(host_name, "Install the host CLI and verify it is in PATH.")
        print(
            f"\n[FATAL ERROR] The host CLI '{host_name}' is not installed or not in PATH.\n"
            f"Hint: {hint}"
        )
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        stderr = (e.stderr or "").strip()
        stdout = (e.stdout or "").strip()
        details = stderr or stdout or f"exit code {e.returncode}"
        print(f"\n[FATAL ERROR] The host '{host_name}' returned an error:\n{details}")
        sys.exit(1)

def run_agent_role(host, role_name, instructions, task_context):
    """Wraps the task in QCHI's strict sub-agent persona."""
    print(f"[*] Spawning [{role_name.upper()}] Agent via {host}...")

    strict_prompt = dedent(
        f"""
        You are the {role_name.upper()} agent within the strict QCHI Research Operating Layer.

        CRITICAL MANDATE:
        {instructions}

        TASK CONTEXT:
        {task_context}

        Do not provide conversational filler. Output only the requested artifact.
        """
    ).strip()

    return execute_host(host, strict_prompt)


def run_qchi_lint(content, lint_bin):
    """
    The Enforcer: Runs the Rust qchi-lint tool.
    If this fails, the CLI will reject the LLM's output.
    """
    print("[-] Running QCHI Rigor Engine (qchi-lint)...")

    if not lint_bin.exists():
        return (
            False,
            (
                f"qchi-lint binary not found at {lint_bin}. "
                "Build it first: cargo build --manifest-path tools/qchi-lint/Cargo.toml"
            ),
        )

    tmp_file = None
    try:
        with tempfile.NamedTemporaryFile(
            mode="w", encoding="utf-8", suffix=".md", delete=False
        ) as handle:
            handle.write(content)
            tmp_file = Path(handle.name)

        cmd = [str(lint_bin), "report", "--file", str(tmp_file)]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            return True, result.stdout.strip() or "Pass"

        details = result.stderr.strip() or result.stdout.strip()
        if not details:
            details = f"qchi-lint exited with status {result.returncode}"
        return False, details
    except Exception as exc:
        return False, f"Failed to run qchi-lint: {exc}"
    finally:
        if tmp_file and tmp_file.exists():
            try:
                tmp_file.unlink()
            except OSError:
                pass


def build_deriver_instructions(last_error=None):
    instructions = (
        "Execute the provided plan. Output markdown only with these exact section headers: "
        "## Problem framing, ## Assumptions and regime, ## Governing equations, ## Derivation, "
        "## Validation checks, ## Final result, ## Interpretation and confidence, "
        "## Claim provenance, ## References. "
        "Inside ## Validation checks, include explicit PASS/FAIL/DEFERRED status lines for: "
        "Unit check, Limiting-case check, Asymptotic check, Consistency check, Symbolic verification. "
        "Symbolic verification must name the tool (Mathematica or SymPy) and include a fenced code block "
        "with the symbolic verification log snippet and outcome. "
        "Include claim provenance tags such as REPRODUCED_FROM_SOURCE / INFERRED_ASSUMPTION / NEW_EXTENSION."
    )
    if last_error:
        instructions += (
            "\n\nYOUR LAST ATTEMPT FAILED THE QUALITY GATE:\n"
            f"{last_error}\n"
            "Fix every failing item and regenerate a fully compliant output."
        )
    return instructions


def orchestrate(args):
    lint_bin = resolve_lint_bin(args.lint_bin)

    print("=========================================")
    print("    QCHI: Research Operating Layer       ")
    print("=========================================")
    print(f"Host: {args.host} | Mode: {args.mode}")
    print(f"Task: {args.task}")
    print(f"Linter: {lint_bin}\n")

    # --- STAGE 1: PLANNER ---
    planner_instructions = "Decompose the given physics task into a verifiable step-by-step derivation plan. Identify all necessary limits and assumptions."
    plan = run_agent_role(args.host, "Planner", planner_instructions, args.task)
    print("\n[PLANNER OUTPUT]\n" + plan + "\n" + "-"*40)

    # --- STAGE 2: DERIVATION (With Feedback Loop) ---
    deriver_instructions = build_deriver_instructions()
    max_retries = args.max_retries
    derivation = ""
    last_error = None

    for attempt in range(1, max_retries + 1):
        if last_error:
            deriver_instructions = build_deriver_instructions(last_error)

        derivation = run_agent_role(args.host, f"Derivation (Attempt {attempt})", deriver_instructions, f"Plan:\n{plan}")

        # --- STAGE 3: THE GATE (Automated Check) ---
        passed, error_msg = run_qchi_lint(derivation, lint_bin)

        if passed:
            print("\n[+] Quality Gate Passed. Derivation accepted.")
            break
        else:
            print(f"\n[!] Quality Gate Failed: {error_msg}")
            last_error = error_msg
            if attempt < max_retries:
                print(f"[*] Forcing AI to retry and fix errors...")
                time.sleep(2)
            else:
                print("\n[FATAL ERROR] Agent failed to produce compliant output after maximum retries. Aborting.")
                sys.exit(1)

    if args.output_file:
        output_path = Path(args.output_file).expanduser()
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(derivation, encoding="utf-8")
        print(f"[*] Saved accepted derivation to {output_path}")

    print("\n[FINAL DERIVATION OUTPUT]\n" + derivation)
    print("=========================================")
    print("[*] QCHI Orchestration Complete.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="QCHI CLI Orchestrator")
    parser.add_argument("--host", choices=SUPPORTED_HOSTS, default="gemini", help="Underlying AI CLI to drive (default: gemini)")
    parser.add_argument("--mode", required=True, help="QCHI Execution Mode")
    parser.add_argument("--task", required=True, help="The physics task or ArXiv ID")
    parser.add_argument("--max-retries", type=positive_int, default=3, help="Maximum derivation retries after quality-gate failure (default: 3)")
    parser.add_argument("--output-file", help="Optional file path for writing the accepted derivation")
    parser.add_argument("--lint-bin", help="Optional path to qchi-lint binary; defaults to env QCHI_LINT_BIN or local target path")

    args = parser.parse_args()
    orchestrate(args)
