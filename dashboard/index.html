<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QCHI Learning Dashboard</title>
  <style>
    :root {
      --bg: #f7f4ec;
      --bg-soft: #f0ead7;
      --panel: rgba(255, 255, 255, 0.8);
      --ink: #1e1a16;
      --muted: #5f554a;
      --line: #d3c8b0;
      --brand: #1b6f63;
      --brand-soft: #c7ebe4;
      --danger: #a7362f;
      --warn: #a05a1a;
      --ok: #1f7a35;
      --track-physics: #1b6f63;
      --track-writing: #9c4f17;
      --track-coding: #2a5398;
      --shadow: 0 12px 30px rgba(30, 26, 22, 0.12);
      --radius: 14px;
      --radius-sm: 10px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      color: var(--ink);
      font-family: "Space Grotesk", "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 500px at 8% -5%, #f7d9b2 0%, transparent 55%),
        radial-gradient(1000px 380px at 95% 6%, #cfe7e2 0%, transparent 52%),
        linear-gradient(180deg, var(--bg-soft) 0%, var(--bg) 55%);
      min-height: 100vh;
    }

    .shell {
      width: min(1200px, 100% - 32px);
      margin: 28px auto 52px;
    }

    .hero {
      border: 1px solid var(--line);
      border-radius: calc(var(--radius) + 4px);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.86), rgba(249, 245, 234, 0.86));
      padding: 22px 24px;
      box-shadow: var(--shadow);
      display: grid;
      gap: 8px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.55rem, 2.8vw, 2.35rem);
      letter-spacing: 0.01em;
    }

    .meta {
      margin: 0;
      color: var(--muted);
      font-size: 0.94rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      width: fit-content;
      padding: 6px 11px;
      border-radius: 999px;
      background: var(--brand-soft);
      color: var(--brand);
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.045em;
    }

    .grid {
      display: grid;
      gap: 14px;
      margin-top: 16px;
      grid-template-columns: repeat(12, minmax(0, 1fr));
    }

    .card {
      grid-column: span 12;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(4px);
    }

    .metric-card {
      grid-column: span 3;
    }

    .metric-label {
      margin: 0;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--muted);
      font-weight: 700;
    }

    .metric-value {
      margin: 8px 0 0;
      font-size: clamp(1.3rem, 2.6vw, 2rem);
      font-weight: 700;
      line-height: 1;
    }

    .metric-sub {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 0.84rem;
    }

    .section-title {
      margin: 0 0 10px;
      font-size: 1.08rem;
      letter-spacing: 0.01em;
    }

    .split {
      display: grid;
      gap: 14px;
      grid-template-columns: 1.35fr 1fr;
    }

    .list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
    }

    .list-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding-bottom: 8px;
      border-bottom: 1px dashed var(--line);
      font-size: 0.92rem;
    }

    .muted {
      color: var(--muted);
      font-size: 0.9rem;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 62px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
      border: 1px solid transparent;
      white-space: nowrap;
    }

    .tag-ok {
      background: rgba(31, 122, 53, 0.14);
      color: var(--ok);
      border-color: rgba(31, 122, 53, 0.35);
    }

    .tag-warn {
      background: rgba(160, 90, 26, 0.14);
      color: var(--warn);
      border-color: rgba(160, 90, 26, 0.35);
    }

    .tag-fail {
      background: rgba(167, 54, 47, 0.12);
      color: var(--danger);
      border-color: rgba(167, 54, 47, 0.3);
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 12px;
    }

    .toolbar label {
      font-size: 0.84rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: end;
    }

    select {
      min-width: 180px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      font: inherit;
      background: #fff;
      color: var(--ink);
    }

    .projects-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .chart-shell {
      border: 1px solid var(--line);
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.62);
      padding: 10px;
      min-height: 160px;
    }

    .chart-host {
      overflow-x: auto;
    }

    .chart-svg {
      width: 100%;
      min-width: 620px;
      height: 320px;
      display: block;
    }

    .chart-empty {
      margin: 8px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .chart-grid {
      stroke: var(--line);
      stroke-width: 1;
      stroke-dasharray: 4 6;
    }

    .chart-axis {
      stroke: #b7ab93;
      stroke-width: 1;
    }

    .chart-axis-label {
      font-size: 10.5px;
      fill: var(--muted);
      font-family: "IBM Plex Mono", "SF Mono", "Consolas", monospace;
    }

    .legend {
      margin: 10px 0 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      font-size: 0.83rem;
      color: var(--muted);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
    }

    .track-card {
      border: 1px solid var(--line);
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.66);
      padding: 12px;
    }

    .track-title {
      margin: 0 0 8px;
      font-size: 0.96rem;
      text-transform: capitalize;
    }

    .kv {
      margin: 0;
      display: grid;
      gap: 6px;
      font-size: 0.86rem;
      color: var(--muted);
    }

    details {
      margin-top: 10px;
    }

    summary {
      cursor: pointer;
      color: var(--brand);
      font-size: 0.85rem;
      font-weight: 700;
      list-style: none;
    }

    summary::-webkit-details-marker {
      display: none;
    }

    summary::before {
      content: "+ ";
      color: var(--muted);
      font-weight: 600;
    }

    details[open] summary::before {
      content: "âˆ’ ";
    }

    pre {
      margin: 8px 0 0;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      max-height: 280px;
      overflow: auto;
      background: #fffdf8;
      font-family: "IBM Plex Mono", "SF Mono", "Consolas", monospace;
      font-size: 0.76rem;
      line-height: 1.45;
    }

    .error {
      color: var(--danger);
      font-weight: 700;
    }

    @media (max-width: 980px) {
      .metric-card {
        grid-column: span 6;
      }

      .split {
        grid-template-columns: 1fr;
      }

      .projects-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 640px) {
      .shell {
        width: min(1200px, 100% - 18px);
        margin-top: 14px;
      }

      .hero,
      .card {
        padding: 14px;
      }

      .metric-card {
        grid-column: span 12;
      }
    }
  </style>
</head>
<body>
  <main class="shell">
    <section class="hero">
      <span class="pill">QCHI Local Dashboard</span>
      <h1>Learning and Reliability Monitor</h1>
      <p id="meta" class="meta">Loading latest snapshot...</p>
    </section>

    <section id="metrics" class="grid" aria-label="Global metrics"></section>

    <section class="card">
      <h2 class="section-title">Global Learning Store</h2>
      <div class="split">
        <div>
          <ul id="global-list" class="list"></ul>
        </div>
        <div>
          <h3 class="section-title" style="font-size:0.96rem; margin-top:0;">Global Heuristics</h3>
          <p id="heuristics-summary" class="muted">Loading heuristics...</p>
          <details>
            <summary>Show `skills/qchi/learning/heuristics.yaml`</summary>
            <pre id="global-heuristics">Loading...</pre>
          </details>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="toolbar">
        <h2 class="section-title" style="margin:0;">Project Tracks</h2>
        <div>
          <label for="project-select">Project</label>
          <select id="project-select"></select>
        </div>
      </div>
      <div id="projects"></div>
    </section>

    <section class="card">
      <div class="toolbar">
        <h2 class="section-title" style="margin:0;">Track Trends</h2>
        <div class="control-row">
          <div>
            <label for="metric-select">Metric</label>
            <select id="metric-select">
              <option value="run_gate_pass_rate">Run gate pass %</option>
              <option value="runs_total">Run count</option>
              <option value="eval_pass_rate">Eval pass %</option>
              <option value="regression_pass_rate">Regression pass %</option>
            </select>
          </div>
          <div>
            <label for="window-select">Window</label>
            <select id="window-select">
              <option value="14">14 days</option>
              <option value="30" selected>30 days</option>
              <option value="90">90 days</option>
            </select>
          </div>
        </div>
      </div>
      <p id="trend-caption" class="muted">Loading trend data...</p>
      <div id="trend-chart" class="chart-shell"></div>
    </section>
  </main>

  <script>
    const TRACKS = ["physics", "writing", "coding-plotting"];
    const TRACK_COLORS = {
      physics: "#1b6f63",
      writing: "#9c4f17",
      "coding-plotting": "#2a5398"
    };

    const dashboardState = {
      projectsMap: {},
      projectName: "",
      metric: "run_gate_pass_rate",
      windowDays: 30
    };

    function asArray(value) {
      return Array.isArray(value) ? value : [];
    }

    function escapeHtml(input) {
      return String(input || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function parseYamlHeuristics(yamlText) {
      const text = String(yamlText || "");
      const ids = [...text.matchAll(/^\s*-\s+id:\s*(.+)$/gm)].map((m) => m[1].trim());
      const promoted = (text.match(/^\s*status:\s*promoted\s*$/gm) || []).length;
      const candidates = (text.match(/^\s*status:\s*candidate\s*$/gm) || []).length;
      const rejected = (text.match(/^\s*status:\s*rejected\s*$/gm) || []).length;
      return {
        total: ids.length,
        promoted,
        candidates,
        rejected
      };
    }

    function countRowsWith(fieldList, rows) {
      return asArray(rows).filter((row) => {
        if (!row || typeof row !== "object") {
          return false;
        }
        return fieldList.some((field) => Object.prototype.hasOwnProperty.call(row, field));
      }).length;
    }

    function percentage(part, total) {
      if (!total) {
        return "n/a";
      }
      return `${Math.round((part / total) * 100)}%`;
    }

    function summaryForBucket(bucket) {
      const runs = asArray(bucket && bucket.runs);
      const evals = asArray(bucket && bucket.evals);
      const regressions = asArray(bucket && bucket.regressions);
      const parseErrors = runs.concat(evals, regressions).filter((x) => x && x._parse_error).length;

      const runCompleted = countRowsWith(["status"], runs);
      const runGatePass = runs.filter((r) => r && r.quality_gate_pass === true).length;
      const evalPass = evals.filter((e) => e && e.pass === true).length;
      const regressionPass = regressions.filter((r) => r && r.pass === true).length;

      return {
        runs: runs.length,
        evals: evals.length,
        regressions: regressions.length,
        parseErrors,
        runCompleted,
        runGatePass,
        evalPass,
        regressionPass,
        evalPassRate: percentage(evalPass, evals.length),
        runGateRate: percentage(runGatePass, runs.length),
        regressionRate: percentage(regressionPass, regressions.length)
      };
    }

    function statusTag(rateText) {
      if (rateText === "n/a") {
        return '<span class="tag tag-warn">n/a</span>';
      }
      const numeric = Number(rateText.replace("%", ""));
      if (numeric >= 85) {
        return `<span class="tag tag-ok">${rateText}</span>`;
      }
      if (numeric >= 60) {
        return `<span class="tag tag-warn">${rateText}</span>`;
      }
      return `<span class="tag tag-fail">${rateText}</span>`;
    }

    function renderMetrics(globalSummary, projectCount, heuristicSummary) {
      const metrics = [
        {
          label: "Runs",
          value: String(globalSummary.runs),
          sub: `Gate pass ${globalSummary.runGateRate}`
        },
        {
          label: "Evals",
          value: String(globalSummary.evals),
          sub: `Pass rate ${globalSummary.evalPassRate}`
        },
        {
          label: "Regressions",
          value: String(globalSummary.regressions),
          sub: `Suite pass ${globalSummary.regressionRate}`
        },
        {
          label: "Projects",
          value: String(projectCount),
          sub: `${heuristicSummary.total} heuristics tracked`
        }
      ];

      const host = document.getElementById("metrics");
      host.innerHTML = metrics.map((item) => `
        <article class="card metric-card">
          <p class="metric-label">${item.label}</p>
          <p class="metric-value">${item.value}</p>
          <p class="metric-sub">${item.sub}</p>
        </article>
      `).join("");
    }

    function renderGlobal(globalBucket) {
      const summary = summaryForBucket(globalBucket);
      const list = document.getElementById("global-list");
      list.innerHTML = `
        <li class="list-row"><span>Total run records</span><strong>${summary.runs}</strong></li>
        <li class="list-row"><span>Run quality-gate pass rate</span>${statusTag(summary.runGateRate)}</li>
        <li class="list-row"><span>Total eval records</span><strong>${summary.evals}</strong></li>
        <li class="list-row"><span>Eval pass rate</span>${statusTag(summary.evalPassRate)}</li>
        <li class="list-row"><span>Total regression records</span><strong>${summary.regressions}</strong></li>
        <li class="list-row"><span>Regression suite pass rate</span>${statusTag(summary.regressionRate)}</li>
        <li class="list-row"><span>JSON parse errors</span><strong class="${summary.parseErrors ? "error" : ""}">${summary.parseErrors}</strong></li>
      `;

      const heuristicsText = String((globalBucket && globalBucket.heuristics_yaml) || "");
      const heuristics = parseYamlHeuristics(heuristicsText);
      const parts = [`${heuristics.total} entries`];
      if (heuristics.promoted) {
        parts.push(`${heuristics.promoted} promoted`);
      }
      if (heuristics.candidates) {
        parts.push(`${heuristics.candidates} candidates`);
      }
      if (heuristics.rejected) {
        parts.push(`${heuristics.rejected} rejected`);
      }

      document.getElementById("heuristics-summary").textContent = parts.join(" | ");
      document.getElementById("global-heuristics").textContent = heuristicsText || "(empty file)";
      return { summary, heuristics };
    }

    function renderProjectTracks(projectName, projectsMap) {
      const container = document.getElementById("projects");
      const project = projectsMap[projectName];
      if (!project) {
        container.innerHTML = "<p class='muted'>No project data found.</p>";
        return;
      }

      const cards = TRACKS.map((track) => {
        const bucket = project[track] || { runs: [], evals: [], regressions: [], heuristics_yaml: "" };
        const summary = summaryForBucket(bucket);
        const heuristics = parseYamlHeuristics(bucket.heuristics_yaml || "");

        return `
          <article class="track-card">
            <h3 class="track-title">${track}</h3>
            <p class="kv">Runs: <strong>${summary.runs}</strong></p>
            <p class="kv">Run gate pass: ${statusTag(summary.runGateRate)}</p>
            <p class="kv">Evals: <strong>${summary.evals}</strong> (${summary.evalPassRate})</p>
            <p class="kv">Regressions: <strong>${summary.regressions}</strong> (${summary.regressionRate})</p>
            <p class="kv">Heuristics: <strong>${heuristics.total}</strong></p>
            <details>
              <summary>Show ${track} heuristics.yaml</summary>
              <pre>${escapeHtml(bucket.heuristics_yaml || "(empty file)")}</pre>
            </details>
          </article>
        `;
      }).join("");

      container.innerHTML = `<div class="projects-grid">${cards}</div>`;
    }

    function parseRowTimestamp(row) {
      if (!row || typeof row !== "object") {
        return null;
      }
      const candidates = ["ts", "timestamp", "created_at", "updated_at", "recorded_at", "run_ts", "date"];
      for (const key of candidates) {
        const raw = row[key];
        if (raw === null || raw === undefined || raw === "") {
          continue;
        }
        let parsed = null;
        if (typeof raw === "number") {
          const millis = raw > 1e12 ? raw : raw * 1000;
          parsed = new Date(millis);
        } else {
          parsed = new Date(String(raw));
        }
        if (!Number.isNaN(parsed.getTime())) {
          return parsed;
        }
      }
      return null;
    }

    function dayKey(dateObj) {
      return dateObj.toISOString().slice(0, 10);
    }

    function dayLabel(dayText) {
      const parsed = new Date(`${dayText}T00:00:00Z`);
      if (Number.isNaN(parsed.getTime())) {
        return dayText;
      }
      return parsed.toLocaleDateString(undefined, { month: "short", day: "numeric" });
    }

    function metricLabel(metric) {
      if (metric === "run_gate_pass_rate") return "Run gate pass %";
      if (metric === "runs_total") return "Run count";
      if (metric === "eval_pass_rate") return "Eval pass %";
      return "Regression pass %";
    }

    function isRateMetric(metric) {
      return metric !== "runs_total";
    }

    function rowsForMetric(bucket, metric) {
      if (metric === "eval_pass_rate") return asArray(bucket && bucket.evals);
      if (metric === "regression_pass_rate") return asArray(bucket && bucket.regressions);
      return asArray(bucket && bucket.runs);
    }

    function rowPass(metric, row) {
      if (metric === "run_gate_pass_rate") return row && row.quality_gate_pass === true;
      if (metric === "eval_pass_rate" || metric === "regression_pass_rate") return row && row.pass === true;
      return false;
    }

    function buildDailySeries(bucket, metric) {
      const rows = rowsForMetric(bucket, metric);
      const byDay = new Map();

      for (const row of rows) {
        const dateObj = parseRowTimestamp(row);
        if (!dateObj) {
          continue;
        }
        const key = dayKey(dateObj);
        const slot = byDay.get(key) || { day: key, total: 0, pass: 0 };
        slot.total += 1;
        if (rowPass(metric, row)) {
          slot.pass += 1;
        }
        byDay.set(key, slot);
      }

      return [...byDay.values()]
        .sort((a, b) => a.day.localeCompare(b.day))
        .map((entry) => {
          if (metric === "runs_total") {
            return { day: entry.day, value: entry.total, total: entry.total, pass: entry.pass };
          }
          const value = entry.total ? (entry.pass / entry.total) * 100 : null;
          return { day: entry.day, value, total: entry.total, pass: entry.pass };
        });
    }

    function shiftDay(dayText, deltaDays) {
      const parsed = new Date(`${dayText}T00:00:00Z`);
      parsed.setUTCDate(parsed.getUTCDate() + deltaDays);
      return parsed.toISOString().slice(0, 10);
    }

    function latestDay(seriesMap) {
      const days = [];
      for (const track of TRACKS) {
        const points = asArray(seriesMap[track]);
        for (const point of points) {
          days.push(point.day);
        }
      }
      if (!days.length) {
        return null;
      }
      days.sort();
      return days[days.length - 1];
    }

    function buildWindowDays(endDay, windowDays) {
      const days = [];
      for (let i = windowDays - 1; i >= 0; i -= 1) {
        days.push(shiftDay(endDay, -i));
      }
      return days;
    }

    function formatMetricValue(metric, value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return "n/a";
      }
      if (isRateMetric(metric)) {
        return `${Math.round(value)}%`;
      }
      return String(Math.round(value));
    }

    function buildTrendSeries(project, metric, windowDays) {
      const rawSeries = {};
      for (const track of TRACKS) {
        rawSeries[track] = buildDailySeries(project[track] || {}, metric);
      }

      const endDay = latestDay(rawSeries);
      if (!endDay) {
        return null;
      }

      const days = buildWindowDays(endDay, windowDays);
      const aligned = [];
      const fallbackValue = metric === "runs_total" ? 0 : null;
      for (const track of TRACKS) {
        const pointMap = new Map(rawSeries[track].map((point) => [point.day, point]));
        const points = days.map((day) => {
          const found = pointMap.get(day);
          return { day, value: found ? found.value : fallbackValue };
        });
        aligned.push({ track, color: TRACK_COLORS[track], points });
      }

      return {
        startDay: days[0],
        endDay: days[days.length - 1],
        series: aligned
      };
    }

    function buildChartSvg(seriesSet, metric) {
      const width = 980;
      const height = 320;
      const margin = { top: 16, right: 18, bottom: 42, left: 56 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;

      const pointCount = seriesSet[0].points.length;
      const xAt = (idx) => {
        if (pointCount <= 1) {
          return margin.left + plotWidth / 2;
        }
        return margin.left + (idx / (pointCount - 1)) * plotWidth;
      };

      const allValues = [];
      for (const series of seriesSet) {
        for (const point of series.points) {
          if (point.value !== null && point.value !== undefined) {
            allValues.push(point.value);
          }
        }
      }

      const yMin = 0;
      let yMax = 100;
      if (!isRateMetric(metric)) {
        const maxValue = allValues.length ? Math.max(...allValues) : 1;
        yMax = Math.max(1, Math.ceil(maxValue * 1.15));
      }

      const yAt = (value) => {
        if (value === null || value === undefined) {
          return null;
        }
        if (yMax === yMin) {
          return margin.top + plotHeight;
        }
        return margin.top + ((yMax - value) / (yMax - yMin)) * plotHeight;
      };

      const gridLines = [];
      const tickCount = 4;
      for (let i = 0; i <= tickCount; i += 1) {
        const ratio = i / tickCount;
        const y = margin.top + ratio * plotHeight;
        const tickValue = Math.round((yMax - ratio * (yMax - yMin)) * 10) / 10;
        const tickLabel = isRateMetric(metric) ? `${Math.round(tickValue)}%` : String(Math.round(tickValue));
        gridLines.push(`<line x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}" class="chart-grid"></line>`);
        gridLines.push(`<text x="${margin.left - 8}" y="${y + 4}" text-anchor="end" class="chart-axis-label">${tickLabel}</text>`);
      }

      const xLabels = [];
      const xStep = Math.max(1, Math.floor(pointCount / 6));
      for (let idx = 0; idx < pointCount; idx += xStep) {
        const x = xAt(idx);
        xLabels.push(`<text x="${x}" y="${height - 12}" text-anchor="middle" class="chart-axis-label">${dayLabel(seriesSet[0].points[idx].day)}</text>`);
      }
      if ((pointCount - 1) % xStep !== 0) {
        const lastX = xAt(pointCount - 1);
        xLabels.push(`<text x="${lastX}" y="${height - 12}" text-anchor="middle" class="chart-axis-label">${dayLabel(seriesSet[0].points[pointCount - 1].day)}</text>`);
      }

      const seriesShapes = [];
      const circles = [];
      for (const series of seriesSet) {
        let current = [];
        const segments = [];

        series.points.forEach((point, idx) => {
          const y = yAt(point.value);
          const x = xAt(idx);
          if (y === null) {
            if (current.length) {
              segments.push(current);
              current = [];
            }
            return;
          }
          current.push([x, y]);
          circles.push(`<circle cx="${x}" cy="${y}" r="2.8" fill="${series.color}"></circle>`);
        });
        if (current.length) {
          segments.push(current);
        }

        for (const segment of segments) {
          const pointsText = segment.map((coords) => `${coords[0]},${coords[1]}`).join(" ");
          seriesShapes.push(
            `<polyline points="${pointsText}" fill="none" stroke="${series.color}" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round"></polyline>`
          );
        }
      }

      const xAxisY = margin.top + plotHeight;
      const axes = [
        `<line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${xAxisY}" class="chart-axis"></line>`,
        `<line x1="${margin.left}" y1="${xAxisY}" x2="${width - margin.right}" y2="${xAxisY}" class="chart-axis"></line>`
      ];

      return `
        <div class="chart-host">
          <svg viewBox="0 0 ${width} ${height}" class="chart-svg" role="img" aria-label="Trend chart">
            ${gridLines.join("")}
            ${axes.join("")}
            ${seriesShapes.join("")}
            ${circles.join("")}
            ${xLabels.join("")}
          </svg>
        </div>
      `;
    }

    function renderTrendChart() {
      const chartHost = document.getElementById("trend-chart");
      const caption = document.getElementById("trend-caption");
      const project = dashboardState.projectsMap[dashboardState.projectName];

      if (!project) {
        caption.textContent = "No project selected.";
        chartHost.innerHTML = "<p class='chart-empty'>No project trend data available.</p>";
        return;
      }

      const trendData = buildTrendSeries(project, dashboardState.metric, dashboardState.windowDays);
      if (!trendData) {
        caption.textContent = `No timestamped records for ${dashboardState.projectName}.`;
        chartHost.innerHTML = "<p class='chart-empty'>Add records with `ts`/timestamp fields to runs, evals, or regressions to render trend lines.</p>";
        return;
      }

      caption.textContent = `${metricLabel(dashboardState.metric)} for ${dashboardState.projectName} by track (${dayLabel(trendData.startDay)} to ${dayLabel(trendData.endDay)}).`;
      const legend = trendData.series.map((series) => {
        const latestPoint = [...series.points].reverse().find((point) => point.value !== null && point.value !== undefined);
        return `
          <li class="legend-item">
            <span class="legend-swatch" style="background:${series.color};"></span>
            <span>${series.track}: ${formatMetricValue(dashboardState.metric, latestPoint && latestPoint.value)}</span>
          </li>
        `;
      }).join("");

      chartHost.innerHTML = `${buildChartSvg(trendData.series, dashboardState.metric)}<ul class="legend">${legend}</ul>`;
    }

    function refreshProjectPanels() {
      renderProjectTracks(dashboardState.projectName, dashboardState.projectsMap);
      renderTrendChart();
    }

    function initProjectSelector(projectsMap) {
      dashboardState.projectsMap = projectsMap || {};
      const selector = document.getElementById("project-select");
      const names = Object.keys(dashboardState.projectsMap);
      if (!names.length) {
        selector.disabled = true;
        selector.innerHTML = "<option>No projects</option>";
        dashboardState.projectName = "";
        document.getElementById("projects").innerHTML = "<p class='muted'>No project learning data yet. Create files under skills/qchi/learning/projects/&lt;project-id&gt;/.</p>";
        renderTrendChart();
        return;
      }

      selector.disabled = false;
      selector.innerHTML = names.map((name) => `<option value="${escapeHtml(name)}">${escapeHtml(name)}</option>`).join("");
      dashboardState.projectName = names[0];
      selector.value = dashboardState.projectName;
      refreshProjectPanels();

      selector.addEventListener("change", () => {
        dashboardState.projectName = selector.value;
        refreshProjectPanels();
      });
    }

    function initTrendControls() {
      const metricSelect = document.getElementById("metric-select");
      const windowSelect = document.getElementById("window-select");
      metricSelect.value = dashboardState.metric;
      windowSelect.value = String(dashboardState.windowDays);

      metricSelect.addEventListener("change", () => {
        dashboardState.metric = metricSelect.value;
        renderTrendChart();
      });

      windowSelect.addEventListener("change", () => {
        dashboardState.windowDays = Number(windowSelect.value) || 30;
        renderTrendChart();
      });
    }

    function toLocalTimestamp(iso) {
      if (!iso) {
        return "unknown";
      }
      const parsed = new Date(iso);
      if (Number.isNaN(parsed.getTime())) {
        return iso;
      }
      return `${parsed.toLocaleString()} (${Intl.DateTimeFormat().resolvedOptions().timeZone})`;
    }

    async function boot() {
      initTrendControls();
      const response = await fetch("learning_data.json", { cache: "no-store" });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      document.getElementById("meta").textContent = `Snapshot generated ${toLocalTimestamp(data.generated_at)} from local learning files.`;

      const globalRender = renderGlobal(data.global || {});
      renderMetrics(globalRender.summary, Object.keys(data.projects || {}).length, globalRender.heuristics);
      initProjectSelector(data.projects || {});
    }

    boot().catch((err) => {
      document.getElementById("meta").innerHTML = `<span class="error">Failed to load dashboard data: ${escapeHtml(err.message)}</span>`;
      document.getElementById("metrics").innerHTML = "";
      document.getElementById("global-list").innerHTML = "<li class='list-row'><span class='error'>Run `python3 bin/qchi dashboard build` then refresh.</span></li>";
      document.getElementById("global-heuristics").textContent = "";
      document.getElementById("heuristics-summary").textContent = "";
      document.getElementById("projects").innerHTML = "";
      document.getElementById("trend-caption").textContent = "";
      document.getElementById("trend-chart").innerHTML = "";
    });
  </script>
</body>
</html>
